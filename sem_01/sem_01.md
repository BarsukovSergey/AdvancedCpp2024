# Linux. Utils. Bash. Vim.

## Linux

### Зачем мы изучаем Linux?
* Наш курс - про язык С++, мы хотим пользоваться некоторыми инструментами (в частности, компилировать код с какими-то опциями, или включать санитайзеры), которые могут быть ОС-специфичными
* Отладка кода на Windows куда как менее удобна
* Если даже обывательское существование для вас может быть удобнее на Windows, то разработка на Linux сопряжена с намного меньшей головной болью, поэтому лучше начинать пользоваться и привыкать с самого начала, все равно рано или поздно придется это сделать - лучше раньше
* На других курсах (АКОС, Concurrency, параллельные и распределенные вычисления) и тем более в будущем на работе так или иначе придется работать под Linux
* Практически все сервера работают под Linux

Если у вас стоит MacOS, то вам, в целом, повезло - почти все (в рамках нашего курса) у вас будет работать так же, но иногда могут возникнуть небольшие проблемы, которые, впрочем, в большинстве случаев несложно решаются.
Итак, приступим.
### Файловая система

Если вы уже сходили на первую пару по матанализу или матлогике, то наверняка уже узнали, что все есть множество. Так вот, в Linux все есть файл.
В частности, _директории_ (а не папки) - тоже файлы особого вида.
Сами по себе директории образуют такую же структуру дерева, как и в других системах. Корнем файловой системы является директория `/`. 
В ней лежит много разного, в частности, `bin`, где лежат основные утилиты, `home`, где лежат домашние директории пользователей, и многое другое.
К каждому файлу можно обратиться, указав его путь. Путь может быть абсолютным (и начинаться с `/`, например:`/home/barsukov/cpp2024`) или относительным (тогда он приписывается к адресу вашей текущей директории, после чего получается абсолютный путь, например, если я нахожусь в `/home`, то относительный адрес из прошлого примера превратится в `barsukov/cpp2024`)
Также в любой директории есть такие поддиректории, как `.` (ссылка на эту же директорию) и `..` (ссылка на родительскую директорию).


### Пользователи

В Linux есть пользователи (users), в других ОС они могут называться аккаунтами или учетными записями, но суть одна.
Пользователи могут объединяться в группы, это сделано для удобства (например, у какого-нибудь сервера будет группа обычных юзеров и группа администраторов с расширенными правами, чтобы не выдавать права каждому отдельно).
Если вы перейдете в директорию `home`, там будут лежать директории для каждого пользователя.
Когда вы находитесь в вашей домашней директории (в моем случае, например, эта директория будет `/home/barsukov`), то ваша директория в терминале будет отображаться как `~`, в ней же вы оказываетесь при запуске терминала, это сделано для удобства.

### Команды

Если в Windows для перемещения по папкам, поиска файлов и вообще произвольных действий с ними вы пользовались графическим интерфейсом, то в Linux вы можете делать это с помощью команд в терминале.
С помощью командной строки можно сделать очень многое, ибо у вас есть множество встроенных инструментов под разные цели, с помощью которых некоторые вещи делаются куда быстрее, чем, например, на Python.
Давайте ознакомимся с базовыми командами, а затем будем узнавать новые в процессе:
* `whoami` - узнать свой username
* `pwd` - узнать текущую директорию (print working directory)
* `date` - текущая дата и время
* `ls` - посмотреть (list) содержимое директории
* `ls "dirname"` - посмотреть содержимое указанной директории
* `users` - вывести список всех пользователей на экран
* `groups` - вывести список всех групп на экран
* `rm "file"` - удалить файл (remove)
* `mv "source" "dest"` - переместить файл (move)
* `cp "source" "dest"` - скопировать файл или несколько файлов (copy)
* `clear` - очистить экран терминала
* `echo` - вывести на экран что-либо


При выполнении команды можно запустить ее с какими-то _флагами_, например, `ls -a` покажет вам все файлы, _включая скрытые_ (например, вы увидите там директории `.` и `..`)

### Файлы

У любого файла могут быть разрешения (или их отсутствие) на три действия: чтение, запись, и исполнение.
Права выставляются отдельно для _владельца_, _группы_, и всех остальных (то есть, для внешнего пользователя).
Чтобы посмотреть список всех файлов в директории с правами (и различной другой информацией), можно выполнить `ls -l`: 
```
-rwxrwxr-x 1 barsukov barsukov 17168 сен 21 02:09 a.out
-rw-rw-r-- 1 barsukov barsukov     6 сен  3 19:40 bla.txt
-rw-rw-r-- 1 barsukov barsukov    66 сен  3 16:43 goodbye2.cpp
-rw-rw-r-- 1 barsukov barsukov    66 сен  3 03:14 goodbye.cpp
drwxrwxr-x 2 barsukov barsukov  4096 сен 21 02:08 new_dir
```
Давайте рассмотрим последний файл: 
* Первая часть `drwxrwxr-x` содержит следующую информацию: сначала указано, что файл является директорией, затем указаны его права (_read_, _write_, _execute_) для владельца, группы, и всех остальных (в данном случае у внешнего пользователя нет прав на запись, все остальные права у всех есть).
* Число 2 - количество ссылок на этот файл (в данном случае их две: из самой директории и из директории выше)
* `username`
* `groupname`
* Размер файла в байтах
* Дата последнего изменения
* Имя файла

Можно поменять права доступа командой `chmod`:
* `chmod +x` - дать всем права на выполнение файла (или на чтение `+r`, запись `+w`)
* `chmod u+x` - дать их только юзеру
* `chmod -x` - отобрать у всех права на выполнение
* `chmod 124` - выставить маску прав: каждое число парсится как бинарная строка длины 3, после чего первый бит пишется в права на чтение, второй на запись, третий на исполнение, например, в данном случае юзер сможет только исполнять файл, группа только читать, а внешний пользователь только исполнять

### Суперпользователь
В Linux есть так называемый _суперпользователь_, который может делать что-то, обходя ограничения. Чтобы запустить процесс от его имени, нужно написать `sudo "do_smth"` (superuser do). Например, вы можете попробовать запретить себе писать в файл и потом его отредактировать - у вас не получится, но под `sudo` это вполне можно сделать. При попытке сделать что-либо от имени суперпользователя вы должны ввести пароль от вашего аккаунта.

У вас может возникнуть вопрос, зачем это нужно? Почему нельзя всегда работать с нормальными правами? Ответ простой: для безопасности. Например, некоторые файлы или директории вы не хотите случайно удалить (допустим, было бы грустно случайно безвозвратно удалить папку `/home`), и для этого можно искусственно запретить себе какие-то действия без явного на то указания.

### Исполняемые файлы
Любой исполняемый файл можно запустить. Чтобы это сделать, нужно указать путь до него. Но есть нюанс: если ваш абсолютный путь состоит только из названия вашего файла, то его нужно писать не как `my_file`, а как `./my_file`. Казалось бы, зачем это нужно? 
Дело в том, что команды, которые вы запускаете - это тоже исполняемые файлы. Откуда терминал знает, где их искать? Когда вы пытаетесь выполнить какую-то команду, терминал это понимает, и ищет соответствующий файл в местах, указанных в _системной переменной_ `PATH`, мы можем посмотреть, что в ней лежит:
```
echo $PATH
/home/barsukov/.local/bin:/usr/local/sbin:/usr/local/bin:/usr/sbin:/usr/bin:/sbin:/bin:/usr/games:/usr/local/games:/snap/bin:/home/barsukov/.local/share/JetBrains/Toolbox/scripts
```
Мы увидели строку, в которой через разделитель `:` лежат _пути_ к директориям, где лежат утилиты.

Поэтому нужно начинать путь с `./`, а если вы напишете просто название вашего файла, то терминал не поймет, что вы от него хотите.

Как исполняется файл? В отличие от Windows, где у файла есть расширение, которое кодируется в его названии, в Linux название у файла может быть совершенно произвольное, и все `.txt`,  `.sh` и прочие приписки - это лишь договоренности.
Но как же тогда работать с файлом? При попытке исполнить файл читается его начало, и по нему должно быть понятно, что делать: 
* Если это бинарный файл, то он начинается с ELF-заголовка
* Если в начале файла есть строка, начинающаяся с `#!`, то текст в этой строке используется как указание на интерпретатор
* Иначе файл запускается интерпретатором `bash` (это язык программирования, на котором мы и писали команды выше).

### Подробнее про команды
Мы уже узнали, что у каждой команды могут быть _флаги_ (они, кстати, обычно либо краткие с одним минусом `ls -a`, либо подробные с двумя `ls --all`). 
Также стоит понимать, что флаги можно комбинировать: например, можно написать `ls -la` - вы увидите список всех файлов, включая скрытые, и подробную информацию о них.
Еще у команд бывают _аргументы_: например, в команду `ls` можно передать аргументом имя директории, и она покажет список файлов в этой директории.
Другие команды:
* `cd "dirname"` - перейти (change directory) в указанную директорию
* `cd ..` - перейти в директорию выше
* `cd -`
* `cd`, `cd ~`, `cd ~username`
* `ls -l` - посмотреть содержимое в подробностях
* `ls -s` - посмотреть с указанием объема
* `ls -R` - посмотреть рекурсивно
* `ls -a` - посмотреть содержимое, включая скрытые файлы
* `wc` - пишет число строк, слов, символов в файле
* `wc -l` - число строк в файле 
* `chmod` - поменять права доступа к файлу
* `sudo`- выполнить команду от имени суперпользователя
* `mkdir` - создать директорию
* `touch "name"` - создать пустой файл
* `touch "name" --date="date"` - установить файлу дату и время (например, `touch aboba.txt –date=”Sun, 29 Feb 2004 16:21:42 -0800”`)
* `cp` - скопировать файл или несколько файлов
* `cp -r` - скопировать директорию (recursively)
* `rm` - удалить файл
* `rm -r` удалить директорию
* `rm -f` - принудительно удалить (если нет прав)
* `cat` - отобразить содержимое файла
* `head`, `tail` - отобразить первые или последние несколько строк, по умолчанию 5 (`head -n 10` - указать количество строк)
* `grep "pattern" "filename` - найти подстроку в файле (`grep “lorem” lorem.txt`)
* `python` - запустить Python в специальном режиме, удобно использовать для каких-то мгновенных действий (что-то посчитать, зарандомить)
* `man "command_name"` - самая важная команда, позволяет посмотреть документацию (manual) к команде (в частности, можно даже спросить `man man`)

### Прочее
* Для копирования текста в терминале нужно его выделить и нажать `Ctrl+Shift+C`, для вставки, аналогично, `Ctrl+Shift+V`, потому что стандартные сочетания клавиш используются под другие цели
* `Ctrl+C` - прервать работающую программу 
* `Ctrl+W` - стереть все слово сразу
* `Ctrl+U` - стереть всю строку сразу
* стрелки вверх-вниз - перемещение по истории команд

### Vim
Vim - это предустановленный текстовый редактор. В нем нужно уметь писать, даже если вы пишете код в какой-нибудь IDE. Во-первых, чтобы не открывать ее на любой чих, это все же большой инструмент, а вам может быть нужно посмотреть какой-нибудь микрофайлик и дописать туда одну строку за секунду. Во-вторых, иногда у вас нет IDE под рукой: допустим, вы подключаетесь к какому-то серверу и там хотите поправить конфиг, и все, что у вас есть - это Vim. 

`vim "filename"` - открыть файл в виме (если такого нет, то автоматически создать)

Есть два режима: command & insert. В командный вас по дефолту кидает, когда вы делаете `vim some_file.txt`. 
Чтобы выйти, нажимаем Esc и пишем `:q!` - выход без сохранения. 
Если нужно сохранить, пишем `:wq`. Чтобы начать писать, в командном режиме тыкаем `i` и пишем начинаем писать. Искать по файлу можно набрав `/something` в командом режиме (предварительно нужно нажать `esc`). 

Вот неплохой гайд https://www.openvim.com/


### Пайпы
Философия команд состоит в том, что каждая команда делает _ровно одну_ вещь, и делает ее хорошо, а сложные вещи декомпозируются на простые.
Для этого нужно понять следующее: у каждой команды есть вход и выход, можно сделать _перенаправление_ (pipe) выхода одной команды на вход другой команде. Синтаксис такой: вы пишете одну команду, потом ставите |, и пишете вторую (`command1 | command2`).

Например, мы хотим найти все вхождения подстроки `"lorem"` в файл `lorem.txt`, но только в первых 100 строках. Как это сделать? Можно сначала вызвать `head`, который выдаст первые 100 строк, а затем натравить на него `grep`, который найдет все подстроки, получается:
```
head -n 100 lorem.txt | grep "lorem"
```

### Продвинутые команды:
* `find -exec` - над всеми найденными файлами выполнить команду
* `more` - отобразить содержимое с возможностью пролистывания
* `less` - отобразить с возможностью пролистывания вверх
* `grep "123.*\.txt"` - использование регулярных выражений (найдет все строки, где есть слово, начинающееся на `123` и заканчивающееся на `.txt`, точка означает любой символ, звездочка - повторение предыдущего символа сколько угодно раз, \ в конце используется для экранирования реальной точки)
* `grep -r` - найти подстроку рекурсивно по файлам
* `grep -w` - поиск точного совпадения слова
* `grep -l` - печатать только имена файлов, в которых найдено совпадение
* `grep -P "aba$" aboba.txt` - найти все подстроки, начинающиеся на данное слово (флаг означает, что это регулярки на Perl) 
* `grep -P "^aba" aboba.txt` - найти все подстроки, заканчивающиеся на данное слово
* `find "dir_name" -name "file_name` - найти файл в директории и ее поддиректориях (`find . -name "*.cpp"` - найти в текущей директории все `.cpp` файлы)
* `grep -P "(^aba|aba$)" aboba.txt` - найти все подстроки, начинающиеся или заканчивающиеся на данное слово
* `sort` - отсортировать строки в файле
* `cut` - порезать файл по столбцам, пример:
* `cat cut.txt | cut -d',' -f1,3` - вырезать из каждой строки первое и третье поле, считая, что поля разделены запятой
* `uniq` - удалить _подряд идущие_ дубликаты строк в файле
* `xargs "command"` - передать входные аргументы на вход следующей команде
Здесь стоит отметить, что входных аргументов может быть много, а поток вывода один, и простой пайп просто отправит весь вывод первой команды на вход второй сплошным текстом. Если передать имена файлов текстом, то они развалятся на отдельные слова, если в них были пробелы.
* `sed` (stream editor) - обработка потока текста:
* `echo "hello hello hello" | sed 's/hello/privet/2'` - заменяет второй hello на privet
* `echo "hello hello hello" | sed 's/hello/privet/g'` - заменяет все вхождения
* `cpuinfo` - посмотреть инфу о процессоре
* `du`, `df` - посмотреть, сколько места на диске
* `{}` - сделать разворачивание списка в терминале
* `sudo -s` или `-i` - стать суперпользователем (su)
* `sudo -u` - выполнить команду от имени другого пользователя
* `tar` - заархивировать или разархивировать
* `ln` - создать жесткую или символическую ссылку

### Упражнения
Попытайтесь придумать, как сделать следующие вещи в терминале:
* Посчитайте, в скольких строках файла строка `aba` встречается хотя бы дважды
<details>
  <summary>Решение</summary>

`grep "aba.*aba" aboba.txt | wc -l`
</details>

* Посчитайте, сколько в проекте есть `.cpp`-файлов
<details>
  <summary>Решение</summary>

`ls -lR | grep ".cpp" | wc -l`
</details>

* Посчитайте количество уникальных строк в файле
<details>
  <summary>Решение</summary>

`cat dublicate.txt | sort | uniq`
</details>

* Выведите список файлов, отсортированных по размеру
<details>
  <summary>Решение</summary>

`ls -ls | sort`
</details>

* Удалите все файлы, содержащие данный текст
<details>
  <summary>Решение</summary>

```grep -lr "text" | xargs rm```

</details>

* Рекурсивно замените все вхождения одного слова на другое в выводе из файла
<details>
  <summary>Решение</summary>

```grep -r "lorem" | sed 's/lorem/ABOBA/'```

</details>

### Потоки
У каждого процесса есть потоки ввода, вывода, и ошибок. По умолчанию ошибки пишутся также на вывод (если вы запустите программу в терминале, то ее ошибки также вылезут на экран). 
Чтобы перенаправить поток (например, вы хотите писать не на экран, а в файл), можно использовать `>`.

* `head lorem.txt > log.txt` - напечатать первые 5 строк файла `lorem.txt` в файл `log.txt`, если такого файла нет - он создастся
* `head lorem.txt >> log.txt` - то же самое, но теперь произойдет дописывание, а не перезатирание

Возможно, вы хотите перенаправить поток вывода в один файл, а ошибок в другой. Стандартные потоки в вышеперечисленном порядке имеют номера 0, 1 и 2 соответственно, а для перенаправления конкретного потока нужно использовать его номер:

* `python 123.py 1>1.txt 2>2.txt` - вывести выход в файл `1.txt`, а ошибки в файл `2.txt`

Если вы хотите, чтобы вывод не печатался на экран, можете отправить его в специальный файл `/dev/null`, все, что туда попадает - пропадает бесследно/

Если вдруг вы хотите, чтобы вывод печатался и на экран, и в файл, то для этого есть специальная команда `tee`: 

* `ls -la | tee files.txt` - напечатает список всех файлов и вам на экран, и в `files.txt`

В С++ стандартные потоки ввода и вывода представлены объектами `std::cin` и `std::cout`, но и у потока ошибок есть свой `std::cerr`, если вы будете выводить что-то в него, оно пойдет в стандартный поток ошибок.

### Установка программ

Чтобы установить себе что-нибудь, можно использовать пакетные менеджеры, основные - это `apt` и `snap`.
Для установки, например, пакета `clang` нужно написать, `sudo apt install clang`.
### IDE или редактор

Самые популярные варианты - CLion (IDE от JetBrains), VSCode, Vim и его аналоги. 
Зачем вообще нужно что-то мощнее текстового редактора? У различных IDE есть много встроенных очень полезных возможностей (начиная с базовых вроде автодополнения, подсветки, go to definition, но вообще ими не ограничиваясь).
* CLion - очень много возможностей из коробки, рекомендуется, если вы хотите сразу начать что-то делать и не хотите заниматься настройкой (по крайней мере, в текущий момент)
* Visual Studio Code - облегченный редактор кода, имеет какие-то встроенные возможности, легко кастомизируется (при желании, всякие простые полезные штуки вы можете настроить себе сами, но на это придется потратить ненулевое количество времени)
* Vim и аналоги - почти ничего нет из коробки, настраивать самим придется все

Часто ведутся холивары на тему того, нужны ли большие IDE: с одной стороны, вы получаете огромное количество функционала из коробки, с другой стороны, в общем случае они будут платными и могут потреблять много памяти.
Единого ответа по этому поводу нет, но важно понимать следующее: платные IDE (например, тот же CLion, он бесплатный только у вас из-за студенческой подписки) разрабатываются большим количеством людей на зарплате, которые за вас улучшают этот продукт и избавляют вас от необходимости кастомизировать ваш редактор самостоятельно (а некоторые вещи делаются очень времязатратно), но взамен, возможно, предоставляют излишнюю функциональность, поедающую ресурсы (впрочем, никто вам не мешает ее отключить)
