# Linux. Utils. Bash. Vim.

## Linux

### Зачем мы изучаем Linux?
* Наш курс - про язык С++, мы хотим пользоваться некоторыми инструментами (в частности, компилировать код с какими-то опциями, или включать санитайзеры), которые могут быть ОС-специфичными
* Отладка кода на Windows куда как менее удобна
* Если даже обывательское существование для вас может быть удобнее на Windows, то разработка на Linux сопряжена с намного меньшей головной болью, поэтому лучше начинать пользоваться и привыкать с самого начала, все равно рано или поздно придется это сделать - лучше раньше
* На других курсах (АКОС, Concurrency, параллельные и распределенные вычисления) и тем более в будущем на работе так или иначе придется работать под Linux
* Практически все сервера работают под Linux

Если у вас стоит MacOS, то вам, в целом, повезло - почти все (в рамках нашего курса) у вас будет работать так же, но иногда могут возникнуть небольшие проблемы, которые, впрочем, в большинстве случаев несложно решаются.
Итак, приступим.
### Файловая система

Если вы уже сходили на первую пару по матанализу или матлогике, то наверняка уже узнали, что все есть множество. Так вот, в Linux все есть файл.
В частности, _директории_ (а не папки) - тоже файлы особого вида.
Сами по себе директории образуют такую же структуру дерева, как и в других системах. Корнем файловой системы является директория `/`. 
В ней лежит много разного, в частности, `bin`, где лежат основные утилиты, `home`, где лежат домашние директории пользователей, и многое другое.
К каждому файлу можно обратиться, указав его путь. Путь может быть абсолютным (и начинаться с `/`, например:`/home/barsukov/cpp2024`) или относительным (тогда он приписывается к адресу вашей текущей директории, после чего получается абсолютный путь, например, если я нахожусь в `/home`, то относительный адрес из прошлого примера превратится в `barsukov/cpp2024`)
Также в любой директории есть такие поддиректории, как `.` (ссылка на эту же директорию) и `..` (ссылка на родительскую директорию).


### Пользователи

В Linux есть пользователи (users), в других ОС они могут называться аккаунтами или учетными записями, но суть одна.
Пользователи могут объединяться в группы, это сделано для удобства (например, у какого-нибудь сервера будет группа обычных юзеров и группа администраторов с расширенными правами, чтобы не выдавать права каждому отдельно).
Если вы перейдете в директорию `home`, там будут лежать директории для каждого пользователя.
Когда вы находитесь в вашей домашней директории (в моем случае, например, эта директория будет `/home/barsukov`), то ваша директория в терминале будет отображаться как `~`, в ней же вы оказываетесь при запуске терминала, это сделано для удобства.

### Команды

Если в Windows для перемещения по папкам, поиска файлов и вообще произвольных действий с ними вы пользовались графическим интерфейсом, то в Linux вы можете делать это с помощью команд в терминале.
С помощью командной строки можно сделать очень многое, ибо у вас есть множество встроенных инструментов под разные цели, с помощью которых некоторые вещи делаются куда быстрее, чем, например, на Python.
Давайте ознакомимся с базовыми командами, а затем будем узнавать новые в процессе:
* `whoami` - узнать свой username
* `pwd` - узнать текущую директорию (print working directory)
* `date` - текущая дата и время
* `ls` - посмотреть (list) содержимое директории
* `ls "dirname"` - посмотреть содержимое указанной директории
* `users` - вывести список всех пользователей на экран
* `groups` - вывести список всех групп на экран
* `rm "file"` - удалить файл (remove)
* `mv "source" "dest"` - переместить файл (move)
* `cp "source" "dest"` - скопировать файл или несколько файлов (copy)
* `clear` - очистить экран терминала
* `echo` - вывести на экран что-либо


При выполнении команды можно запустить ее с какими-то _флагами_, например, `ls -a` покажет вам все файлы, _включая скрытые_ (например, вы увидите там директории `.` и `..`)

### Файлы

У любого файла могут быть разрешения (или их отсутствие) на три действия: чтение, запись, и исполнение.
Права выставляются отдельно для _владельца_, _группы_, и всех остальных (то есть, для внешнего пользователя).
Чтобы посмотреть список всех файлов в директории с правами (и различной другой информацией), можно выполнить `ls -l`: 
```
-rwxrwxr-x 1 barsukov barsukov 17168 сен 21 02:09 a.out
-rw-rw-r-- 1 barsukov barsukov     6 сен  3 19:40 bla.txt
-rw-rw-r-- 1 barsukov barsukov    66 сен  3 16:43 goodbye2.cpp
-rw-rw-r-- 1 barsukov barsukov    66 сен  3 03:14 goodbye.cpp
drwxrwxr-x 2 barsukov barsukov  4096 сен 21 02:08 new_dir
```
Давайте рассмотрим последний файл: 
* Первая часть `drwxrwxr-x` содержит следующую информацию: сначала указано, что файл является директорией, затем указаны его права (_read_, _write_, _execute_) для владельца, группы, и всех остальных (в данном случае у внешнего пользователя нет прав на запись, все остальные права у всех есть).
* Число 2 - количество ссылок на этот файл (в данном случае их две: из самой директории и из директории выше)
* `username`
* `groupname`
* Размер файла в байтах
* Дата последнего изменения
* Имя файла

Можно поменять права доступа командой `chmod`:
* `chmod +x` - дать всем права на выполнение файла (или на чтение `+r`, запись `+w`)
* `chmod u+x` - дать их только юзеру
* `chmod -x` - отобрать у всех права на выполнение
* `chmod 124` - выставить маску прав: каждое число парсится как бинарная строка длины 3, после чего первый бит пишется в права на чтение, второй на запись, третий на исполнение, например, в данном случае юзер сможет только исполнять файл, группа только читать, а внешний пользователь только исполнять

### Суперпользователь
В Linux есть так называемый _суперпользователь_, который может делать что-то, обходя ограничения. Чтобы запустить процесс от его имени, нужно написать `sudo "do_smth"` (superuser do). Например, вы можете попробовать запретить себе писать в файл и потом его отредактировать - у вас не получится, но под `sudo` это вполне можно сделать. При попытке сделать что-либо от имени суперпользователя вы должны ввести пароль от вашего аккаунта.

У вас может возникнуть вопрос, зачем это нужно? Почему нельзя всегда работать с нормальными правами? Ответ простой: для безопасности. Например, некоторые файлы или директории вы не хотите случайно удалить (допустим, было бы грустно случайно безвозвратно удалить папку `/home`), и для этого можно искусственно запретить себе какие-то действия без явного на то указания.

### Исполняемые файлы
Любой исполняемый файл можно запустить. Чтобы это сделать, нужно указать путь до него. Но есть нюанс: если ваш абсолютный путь состоит только из названия вашего файла, то его нужно писать не как `my_file`, а как `./my_file`. Казалось бы, зачем это нужно? 
Дело в том, что команды, которые вы запускаете - это тоже исполняемые файлы. Откуда терминал знает, где их искать? Когда вы пытаетесь выполнить какую-то команду, терминал это понимает, и ищет соответствующий файл в местах, указанных в _системной переменной_ `PATH`, мы можем посмотреть, что в ней лежит:
```
echo $PATH
/home/barsukov/.local/bin:/usr/local/sbin:/usr/local/bin:/usr/sbin:/usr/bin:/sbin:/bin:/usr/games:/usr/local/games:/snap/bin:/home/barsukov/.local/share/JetBrains/Toolbox/scripts
```
Мы увидели строку, в которой через разделитель `:` лежат _пути_ к директориям, где лежат утилиты.

Поэтому нужно начинать путь с `./`, а если вы напишете просто название вашего файла, то терминал не поймет, что вы от него хотите.

Как исполняется файл? В отличие от Windows, где у файла есть расширение, которое кодируется в его названии, в Linux название у файла может быть совершенно произвольное, и все `.txt`,  `.sh` и прочие приписки - это лишь договоренности.
Но как же тогда работать с файлом? При попытке исполнить файл читается его начало, и по нему должно быть понятно, что делать: 
* Если это бинарный файл, то он начинается с ELF-заголовка
* Если в начале файла есть строка, начинающаяся с `#!`, то текст в этой строке используется как указание на интерпретатор
* Иначе файл запускается интерпретатором `bash` (это язык программирования, на котором мы и писали команды выше).

### Подробнее про команды
Мы уже узнали, что у каждой команды могут быть _флаги_ (они, кстати, обычно либо краткие с одним минусом `ls -a`, либо подробные с двумя `ls --all`). 
Также стоит понимать, что флаги можно комбинировать: например, можно написать `ls -la` - вы увидите список всех файлов, включая скрытые, и подробную информацию о них.
Еще у команд бывают _аргументы_: например, в команду `ls` можно передать аргументом имя директории, и она покажет список файлов в этой директории.
Другие команды:
* `cd "dirname"` - перейти (change directory) в указанную директорию
* `cd ..` - перейти в директорию выше
* `cd -`
* `cd`, `cd ~`, `cd ~username`
* `ls -l` - посмотреть содержимое в подробностях
* `ls -s` - посмотреть с указанием объема
* `ls -R` - посмотреть рекурсивно
* `ls -a` - посмотреть содержимое, включая скрытые файлы
* `wc` - пишет число строк, слов, символов в файле
* `chmod` - поменять права доступа к файлу
* `sudo`- выполнить команду от имени суперпользователя
* `mkdir` - создать директорию
* `touch "name"` - создать пустой файл
* `touch "name" --date="date"` - установить файлу дату и время (например, `touch aboba.txt –date=”Sun, 29 Feb 2004 16:21:42 -0800”`)
* `cp` - скопировать файл или несколько файлов
* `cp -r` - скопировать директорию (recursively)
* `rm` - удалить файл
* `rm -r` удалить директорию
* `rm -f` - принудительно удалить (если нет прав)
* `cat` - отобразить содержимое файла
* `head`, `tail` - отобразить первые или последние несколько строк, по умолчанию 5 (`head -n 10` - указать количество строк)
* `grep "pattern" "filename` - найти подстроку в файле (`grep “lorem” lorem.txt`)
* `grep -r` - найти подстроку рекурсивно по файлам
* `grep -w` - поиск точного совпадения слова
* `find "dir_name" -name "file_name` - найти файл в директории и ее поддиректориях (`find . -name "*.cpp"` - найти в текущей директории все `.cpp` файлы)
* `python` - запустить Python в специальном режиме, удобно использовать для каких-то мгновенных действий (что-то посчитать, зарандомить)
* `man "command_name"` - самая важная команда, позволяет посмотреть документацию (manual) к команде (в частности, можно даже спросить `man man`)

### Прочее
* Для копирования текста в терминале нужно его выделить и нажать `Ctrl+Shift+C`, для вставки, аналогично, `Ctrl+Shift+V`, потому что стандартные сочетания клавиш используются под другие цели
* `Ctrl+C` - прервать работающую программу 
* `Ctrl+W` - стереть все слово сразу
* `Ctrl+U` - стереть всю строку сразу
* стрелки вверх-вниз - перемещение по истории команд
* 
### Пайпы

Философия команд состоит в том, что каждая команда делает _ровно одну_ вещь, и делает ее хорошо, а сложные вещи декомпозируются на простые.
Для этого нужно понять следующее: у каждой команды есть вход и выход, можно сделать _перенаправление_ (pipe) выхода одной команды на вход другой команде. Синтаксис такой: вы пишете одну команду, потом ставите |, и пишете вторую (`command1 | command2`).

Например, мы хотим найти все вхождения подстроки `"lorem"` в файл `lorem.txt`, но только в первых 100 строках. Как это сделать? Можно сначала вызвать `head`, который выдаст первые 100 строк, а затем натравить на него `grep`, который найдет все подстроки, получается:
```
head -n 100 lorem.txt | grep "lorem"
```

### Установка программ

Чтобы установить себе что-нибудь, можно использовать пакетные менеджеры, основные - это `apt` и `snap`.
Для установки, например, пакета `clang` нужно написать, `sudo apt install clang`.
### IDE или редактор

Самые популярные варианты - CLion (IDE от JetBrains), VSCode, Vim и его аналоги. 
Зачем вообще нужно что-то мощнее текстового редактора? У различных IDE есть много встроенных очень полезных возможностей (начиная с базовых вроде автодополнения, подсветки, go to definition, но вообще ими не ограничиваясь).
* CLion - очень много возможностей из коробки, рекомендуется, если вы хотите сразу начать что-то делать и не хотите заниматься настройкой (по крайней мере, в текущий момент)
* Visual Studio Code - облегченный редактор кода, имеет какие-то встроенные возможности, легко кастомизируется (при желании, всякие простые полезные штуки вы можете настроить себе сами, но на это придется потратить ненулевое количество времени)
* Vim и аналоги - почти ничего нет из коробки, настраивать самим придется все

Часто ведутся холивары на тему того, нужны ли большие IDE: с одной стороны, вы получаете огромное количество функционала из коробки, с другой стороны, в общем случае они будут платными и могут потреблять много памяти.
Единого ответа по этому поводу нет, но важно понимать следующее: платные IDE (например, тот же CLion, он бесплатный только у вас из-за студенческой подписки) разрабатываются большим количеством людей на зарплате, которые за вас улучшают этот продукт и избавляют вас от необходимости кастомизировать ваш редактор самостоятельно (а некоторые вещи делаются очень времязатратно), но взамен, возможно, предоставляют излишнюю функциональность, поедающую ресурсы (впрочем, никто вам не мешает ее отключить)
