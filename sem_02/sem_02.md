# 2. Expressions, operators, CE, RE, UB

## Expressions 
### Operator Precedence

В С++ есть много разных операторов, большинство (или все) из них вам уже знакомы:

* `::` - Scope resolution
* `+ - * / %` - арифметические
* `++ --` - префиксные и постфиксные инкремент и декремент
* `&& || !` - логические
* `& | ^ ~` - битовые
* `< > <= >=` - порядок
* `== !=` - эквивалентность
* `= += -= /= *= %= >>= <<=` - присваивания и составные присваивания
* и разные другие, [полный список](https://en.cppreference.com/w/cpp/language/operator_precedence)

Вообще говоря, операторы - это синтаксический сахар, когда (для нетривиальных типов) вы пишете `a + b`, то это просто превращается в `operator+(a, b)`. Сделано это, понятное дело, для удобства, чтобы не писать для своих типов странные вещи типа `plus(a, plus(b, (plus(c, d))))`.
Но есть и минусы: из-за такой записи становится неочевидным приоритет операторов, поэтому существует понятие [C++ Operator Precedence](https://en.cppreference.com/w/cpp/language/operator_precedence).

Этот список правил говорит именно о приоритете операций, то есть, например, о том, что в выражении `a + b * c` произойдет сначала умножение `b` на `c`, а уже потом сложение результата с `a`.
Кроме этого, про каждый оператор сказано, является ли он право- или левоассоциативным, например, в выражении `a + b + c` гарантированно произойдет сначала левое сложение, а потом правое, а в выражении `a = b = c` сначала выполнится второе присваивание, а потом первое, и в результате все переменные будут равны `c` по значению.

### Order of evaluation

Если задуматься, то приоритета операторов недостаточно, чтобы понимать, что на самом деле будет происходить при вычислении некого выражения. Например, в выражении `sin(1) + sin(2) + sin(3)` понятно, что трижды посчитается синус и результаты сложатся неважно в каком порядке, но в каком порядке будут происходить вызовы функций?
Может показаться, что это неважно. Но если вместо синуса будет какая-то функция, которая, например, что-то печатает на экран? В каком порядке все напечатается?

Для решения этого вопроса в стандарте С++ есть понятие [Order of evaluation](https://en.cppreference.com/w/cpp/language/eval_order). Оно вводит правила, по которым вычисляются части выражений.

Вообще говоря, в большинстве случаев порядок вычислений операндов выражения не определен, о чем страничка на cppreference любезно сообщает сразу на входе. Например, в нашем примере выше синусы могут вычислиться в любом порядке (несмотря на то, что складываться они будут слева направо!).
В частности, выражение не обязано вычислять справа налево или слева направо. Но все же, некоторые правила есть, иначе жизнь была бы весьма трудна.
Для того чтобы с этим разобраться, стандарт вводит дополнительные термины. Вычисление каждого выражения содержит две части:
* `Value computations` - вычисление значения, возвращаемого выражением
* `Initiation of side effects` - изменение каких-либо объектов, ввод-вывод на экран и прочее

Также любые два вычисления могут находиться в отношении `Sequenced before` друг с другом, что означает, что одно событие _случилось раньше_ другого. Два события могут быть упорядочены во времени (одно происходит раньше другого) или не упорядочены (относительный порядок их вычисления может быть любым).
Важно: в общем случае нет никакого глобального порядка, в соответствии с которым гарантированно будут вычисляться разные вещи в вашей программе, можно только для _двух конкретных событий_ понять, правда ли, что одно случится раньше другого.

На вышеприведенной страничке есть подробный список из 20 правил, естественно, его не нужно знать, но глобально полезно понимать, что порядок вычисления выражений - нетривиальная вещь.
Тем не менее некоторые основные вещи знать полезно:
* Вычисление значения и сайд-эффекты у любого _полного выражения_ происходят раньше, чем у следующего полного выражения
* Вычисления значений операндов (но не сайд-эффекты!) происходят раньше, чем вычисление результата оператора
* При вызове функции вычисление ее аргументов происходит раньше, чем любые выражения в теле функции
* У префиксных инкремента и декремента значение вычисляется раньше сайд-эффекта, а у постфиксных - наоборот
* У логических операторов `||` и `&&` вычисление левого операнда и его сайд-эффект происходят раньше, чем правого
* В тернарном операторе первый операнд вычисляется целиком раньше, чем второй и третий (а вот они уже не упорядочены)
* Начиная с С++17, в операторе присваивания (и составного присваивания) правая часть вычисляется раньше левой
* При обращении по индексу `A[B]`, вводе `A >> B` и выводе `A << B` в поток левая часть вычисляется раньше правой 
* При перегрузке операторов правила `sequenced-before` для них не меняются и работают как и для стандартных
* Вычисление аргументов функции __неупорядоченно__

Чуть позже мы обсудим примеры того, что может происходить при работе с неупорядоченными эффектами.

### As-if rule

В С++ есть понятие [As-if rule](https://en.cppreference.com/w/cpp/language/as_if). Согласно этому правилу, компилятору разрешено делать любые действия с вашей программой, которые не будут менять ее _наблюдаемое поведение_.
Например, файловый ввод-вывод не должен меняться. Если вы знаете, что такое `volatile` объекты, то доступ к ним тоже не должен переупорядочиваться.

В частности, выше мы обсудили понятие порядка вычислений. Теперь мы можем понять, что если два вычисления не упорядочены друг относительно друга (можно думать об этом как о поиске пути в направленном графе, где ребро проводится при наличии упорядоченности), то компилятор имеет полное право выполнять эти вычисления в любом порядке друг относительно друга (по сути, ему нужно обойти весь граф вычислений в любом порядке, который был бы согласован с ребрами). 
Как следствие, если ваша программа меняет поведение при произвольном переупорядочивании неупорядоченных вычислений, то она некорректна. 

Разумеется, корректно определить понятие наблюдаемого поведения можно только у корректных программ: компилятор может как-то поменять ваш код, и если ваша программа корректна, то ее поведение при этом не поменяется (собственно, на этой концепции основаны оптимизации компилятора), а если она не была корректной, то поведение вполне может измениться.
Например, если вы сделаете проверку на переполнение знакового типа путем 
```c++
if (n + 1 < n) {
    // do smth
}
```
то компилятор имеет право заключить, что условие ифа никогда не может быть верно (так как переполнение знакового типа - неопределенное поведение!), а посему можно весь этот кусок с проверкой просто выпилить и не запускать вовсе. 

## Operators

### Conditional operator
Тернарный оператор имеет синтаксис `condition ? exp_1 : exp_2`, где первый операнд вычисляется и конвертируется в `bool`, затем, если получилась истина, возвращается второй операнд, иначе третий.

* Возвращаемый тип тернарного оператора - наилучший общий тип для типов выражений `expr_1` и `expr_2`. Важно: это верно всегда, даже если в условие вы напишете `true`, все равно он приведет результат к общему типу. Почему так? Потому что тип любого выражения должен быть известен _на этапе компиляции_, поэтому правила вывода типа для тернарного оператора не зависят (и не могут зависеть!) от значений аргументов.
Что будет, если типы несовместимы? [Ошибка компиляции](incompatible.cpp) `02-incompatible`:
```c++
#include <string>
int main() {
    int x = 1;
    std::string s = "aboba";
    (1 < 2 ? x : s) = 6;
    return 0;
}
```
* Тип `value` у результата - `lvalue` тогда и только тогда, когда второй и третий операнд являются `lvalue`, и `rvalue` иначе. Посмотрим на [пример](conditional.cpp) `02-conditional`:
```c++
int main() {
    int a = 1;
    (true ? ++a : a++) = 1;
    return 0;
}
```
Несмотря на то, что выражение истинно и возвращается вроде как результат преинкремента, вид `value` (как и тип) выражения все равно должен быть вычислен на этапе компиляции и не зависеть от значений аргументов, поэтому результат должен быть `rvalue`, и код падает с ошибкой компиляции `lvalue required as left operand of assignment`.

* Даже если оба операнда были `lvalue`, но случилась конверсия типов, то результат все равно будет `rvalue`, ибо после преобразования типа выражение перестает быть `lvalue`, [например](conversion.cpp) `02-conversion`:
```c++
int main() {
    int a = 1;
    double b = 2;
    (1 < 2 ? a : b) = 1;
    return 0;
}
```
Несмотря на то, что в обоих случаях, казалось бы, возвращается переменная, мы уже выяснили, что тип этого выражения - `double`. Коль скоро оно так, то в данном случае вернется `a` (вообще-то, типа `int`), которое перед этим прикастуется к `double`, и вернется по факту уже временное значение (а не исходная переменная), которое, естественно, `rvalue`, и ничего присвоить ему уже нельзя. Ну, и так как вся эта история опять-таки происходит на этапе компиляции, то так будет работать всегда независимо от значений операндов.

### Comma operator

Оператор _запятая_ - бинарный, имеет синтаксис `expr_1, expr_2`, и делает следующее: вычисляет левую часть целиком, затем правую и возвращает правую. Значение, тип и вид `value` совпадает с таковыми у правой части. 

Важно помнить, что запятая, разделяющая аргументы функции - __не оператор__, а просто элемент синтаксиса.

Оператор запятая обладает самым низким приоритетом среди всех операторов.

## CE, RE, UB

Мы переходим к изучению различных ошибок в программе. Начнем с простого: ошибки компиляции.

### Compile errors
Ошибки компиляции - это прекрасная вещь, поскольку мы их можем найти, не запуская наш код вообще. Этим компилируемые языки выгодно отличаются от интерпретируемых: если вы напишете какой-то огромный код на питоне, в котором где-то допустили тупую ошибку, то вы дойдете до нее и упадете только в этот момент, хотя ошибка могла быть легко обнаружимой изначально. В С++ же компилятор вас поругает за всевозможные отлавливаемые на этом этапе грехи, и вы сразу сможете их поправить, не запуская код.

Компиляция программы - вещь многошаговая, и в зависимости от того, на каком этапе все сломалось, ошибки компиляции можно делить на несколько типов:

Первый этап - это лексический анализ текста, компилятор пытается разбить текст на токены (и про каждый из них понять, кто это), с которыми уже дальше будет работать. Например, строка `std::cin >> x;` разбивается на токены `std`, `::`, `cin`, `>>`, `x`, `;`.
* Лексическая ошибка

Это ошибка "что ты сейчас вообще сказал?". Она случается, когда компилятор не смог даже понять, что вы от него хотите, [например](lexical.cpp), вы использовали недопустимое название переменной `02-lexical`:
 ```c++
 int main() {
    int \\ = 3;
 }
 ```
Этому тексту не получается даже никакой смысл вообще придать. Проводя аналогию с русским языком, текст нельзя даже на слова разбить

Второй этап - синтаксический анализ, компилятор пытается составить из токенов осмысленные "фразы", например, понять, где выражение, а где определение.
* Синтаксическая ошибка

Это ошибка "что ты хочешь сделать?". Она случается, когда компилятор смог разбить текст на токены, но дальше он не смог их как-то нормально сматчить, [например](syntax.cpp) `02-syntax`:
```c++
 int main() {
    2 + ;
 }
 ```
Понятно, как разбить эту строку на токены: это выражение, в котором сначала 2, потом оператор +, потом конец выражения. Но оператор + воспринимается в данном контексте только как бинарный, а второго операнда нет, поэтому синтаксически предложение некорректно, компилятор нам пишет `error: expected primary-expression before ';' token`

Вообще, когда у вас вылезает ошибка компиляции такого вида, скорее всего, вы где-то забыли скобку или вообще написали что-то странное. Продолжая аналогию, здесь вы сказали предложение, которое можно на слова разбить, но предложение осмысленное из них не собирается, типа "я грибами за в лес пошел"  

Когда текст разбит на токены и "фразы", то дальше можно попытаться наделить его смыслом, и мы приходим к этапу семантического анализа.
* Семантическая ошибка

Самый частый вид ошибок, который будет у вас чаще всего возникать и сложнее всего чиниться. Это ошибка "я понял, что ты сказал и что ты хочешь сделать, но так вообще-то нельзя".

**Пример:** неопределённая операция над типами

 ```c++
 int main() {
    "abc" + 2.0f;
 }
 ```

**Пример:** обращение к необъявленной переменной
 ```c++
 int main() {
    std::cout << x;
 }
 ```

**Пример:** неоднозначное обращение к переменной
 ```c++
 namespace n1 {
    int x = 3;
 }

 namespace n2 {
    int x = 5;
 }

 int main() {
    using namespace n1;
    using namespace n2;

    std::cout << x;  // Moreover, commenting this line removes the error!
 }
 ```
В терминах русского языка, семантическая ошибка - это "я съел стол". Понятно, что сказано и как это понять, но так нельзя, человеку не разрешено есть стол.

### Runtime Errors

Что такое runtime error? Это ошибка времени выполнения, то есть, программа скомпилировалась в машинный код, код запустился и упал во время его выполнения.
Самый частый пример ошибки времени выполнения - это `Segmentation Fault`. На низком уровне тут происходит куча всего, но вообще, эта ошибка значит, что вы пытаетесь обратиться к памяти, к которой не имеете доступа. 

[Например](segfault.cpp), давайте возьмем вектор и тыкнемся в память, которая явно за его пределами `02-segfault`:
```c++
#include <vector>
#include <iostream>
int main() {
    std::vector<int> a(10);
    a[50000] = 1;
    std::cout << a[50000];
}
```
Еще примеры:

* [Floating point exception](fpe.cpp) в результате целочисленного деления на 0 (название сохранилось исторически, это не является _исключением_) `02-fpe` 
```c++
#include <iostream>
int main() {
    int d;
    std::cin >> d;  // input d = 0
    std::cout << 1 / d;
}
```

* [Aborted](abort.cpp) в результате принудительного завершения исполнения, вызванное самой программой (в данном случае, непойманное исключение) `02-abort`
```c++
#include <iostream>
#include <vector>
int main() {
    std::vector<int> v;
    std::cout << v.at(0);
}
```
Еще aborted можно поймать, если сделать `assert` на ложное условие. Вообще, ассерт - это способ сказать "это условие должно быть истинно, а иначе пусть программа упадет сразу". У тех, кто знаком с исключениями, может возникнуть вопрос, а зачем же тогда нужны ассерты?
Исключения нужны для отлова каких-то адекватных ошибок, например, `vector.at()`, в случае вылезания за границы массива, кинет вам исключение, а ассерт проверяет какой-то инвариант, который в целом должен быть выполнен, и используется только в дебажной сборке, а в релизной отключается.
Например, вы почему-то знаете, что в процессе исполнения вашего кода значение какой-то переменной никогда не превысит, допустим, 1000. Тогда можно в целях дебага написать `assert(var <= 1000)`, и если ассерт упадет - то где-то вы накосячили. 
Если ассерт встречает истинное условие - не происходит ничего, а если ложное, то вызывается функция `abort()` и программа аварийно завершается. [Пример](assert.cpp) `02-assert`:
```cpp
#include <cassert>

int main() {
    assert(2 + 2 == 5);
    return 0;
}
```


### Undefined behaviour
