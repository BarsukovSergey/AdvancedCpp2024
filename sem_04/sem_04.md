# Complicated declarations, 

## Complicated declarations
Мы уже научились делать простые объявления:
```c++
int foo[5];     // foo is an array of 5 ints
char* foo;      // foo is a pointer to char
double foo();   // foo is a function returning a double
```
Вспомним, как делать объявления чуть посложнее:
```c++
int* arr[5]; // array of 5 pointers to int
int (*arr)[5]; // pointer to array of 5 ints
```
Как отличать эти две вещи? Надо помнить, что токены парсятся жадно, поэтому компилятор воспринимает `*` в первой строке как относящуюся к инту, а не к массиву.
Поэтому, когда мы пишем объявление по типу того, что в первой строке, получается массив из указателей (слева написан тип, который лежит в массиве, и `*` - его часть), а если мы хотим получить _указатель на массив_, то надо это указать явно скобками.
Еще можно вспомнить аналог с объявлением `int *x` - звезда приписывается к имени, как будто бы мы объявили просто инт, а не указатель, и здесь, если читать `(*arr)` как единое название, работает такая же логика.

Но иногда объявления могут быть очень запутанными, и читать их становится несколько _проблематично_:
```c++
char *(*(**foo[][8])())[]; // what
```

### Basic and derived types
На самом деле, понимать даже такие типы не очень сложно, давайте попробуем с этим разобраться.
Для начала зафиксируем, как образуются типы. Есть набор базовых типов: `int, long, char, void...`, и есть производные типы от них. 
Любое объявление имеет __ровно один__ базовый тип, и он стоит в самой левой части выражения. Производный тип бывает одного из трех видов:
* `*: pointer to...` - помечается `*` (и всегда должен быть _указатель на что-то_)
* `[]: array of...` - может быть с указанной размерностью или без нее (и всегда _массив чего-то_)
Вообще, в С++ при объявлении многомерного массива должны быть указаны все размерности, кроме самой первой, но для нашей локальной задачи разобраться с объявлениями это неважно.
* `(): function returning...` - обычно обозначается `()`, в которых написан список типов аргументов. Функция всегда _возвращает что-то_ (в данном контексте синтаксически проигнорируем тип `void` и сделаем вид, что это тоже полноценный тип). Скобки, используемые для обозначения `function, returning...`, отличаются от тех, которые используются для группировки: группирующие скобки находятся с обеих сторон от имени, тогда как "функциональные" находятся справа.

### Operators Precedence
На прошлом семинаре мы узнали, что у операторов есть разный приоритет, что позволяет однозначно парсить выражения. Для "нормальных" выражений это кажется естественным, но для выражений типов верны те же правила.
Операторы "array of"`[]` и "function returning"`()` имеют приоритет выше, чем "pointer to"`*`. Также объявление всегда начинается с имени переменной:

<strong>foo is </strong>...

и всегда заканчивается базовым типом

foo is ... <strong> int</strong>

Все, что нужно написать в середине, пишется по одному простому правилу: мы начинаем с имени переменной, затем идем направо, _пока можем_, и налево, _если должны_.

Например, давайте разберем тип `long** foo[8]`. Для начала, мы уже знаем начало и конец:

<strong>foo is ... long </strong>

Читаем справа, получаем `foo[8]`, поэтому

foo is <strong>array of 8...</strong> long

Больше справа ничего нет, поэтому идем влево и читаем `*`, получаем `*foo[8]`:

foo is array of 8 <strong>pointers to...</strong> long

Читаем еще одну `*` и завершаем:

foo is array of 8 pointers to <strong>pointer to</strong> long

Давайте завершим смертельным номером, расшифруем 
```c++
char *(*(**foo[7][8])())[]; // what
```
Итак, начнем:
* `foo[]` - **foo is array of**...
* `foo[][8]` - foo is array of **arrays of 8**...
* `foo[][8])` - уткнулись в скобку, нужно читать влево
* `*foo[][8])` - foo is array of arrays of 8 **pointers to**...
* `**foo[][8])` - foo is array of arrays of 8 pointers to **pointer to**...
* `(**foo[][8])` - нашли открывающую скобку, вышли из скобки, идем вправо
* `(**foo[][8])()` - foo is array of arrays of 8 pointers to pointer to **function, taking nothing and returning**... (если бы у функции были какие-либо аргументы, их типы были бы написаны как раз в этих скобках)
* `(**foo[][8])())` - уткнулись в скобку, нужно читать влево
* `*(**foo[][8])())` - foo is array of arrays of 8 pointers to pointer to function, taking nothing and returning **pointer to**...
* `(*(**foo[][8])())` - нашли открывающую скобку, вышли из скобки, идем вправо
* `(*(**foo[][8])())[7]` - foo is array of arrays of 8 pointers to pointer to function, taking nothing and returning pointer to **array of 7**...
* `(*(**foo[][8])())[7];` - строка кончилась, дальше идем только влево
* `*(*(**foo[][8])())[7];` - foo is array of arrays of 8 pointers to pointer to function, taking nothing and returning pointer to array of 7 **pointers to**...
* `char *(*(**foo[][8])())[7];` - foo is array of arrays of 8 pointers to pointer to function, taking nothing and returning pointer to array of 7 pointers to **char**

### Abstract declarations

Мы знаем, что в С++ иногда можно не указывать имя переменной. Это используется в кастах, при вызове `sizeof`, при объявлении функции. Например, мы хотим прочитать следующий тип:
```c++
int (*(*)())()
```
Как его читать? Вернее, откуда начать это делать? Мы уже поняли, что если бы было написано имя переменной, то мы бы легко прочитали тип. Значит, надо понять, где может стоять имя, а потом читать все как обычно.

Есть только одно место, где может стоять имя переменной (иначе бы и компилятор не мог его понять). Существуют следующие синтаксические правила: имя переменной стоит
* справа от всех токенов "pointer to" `*`
* слева от всех токенов "array of" `[]`
* слева от всех токенов "function returning"`()`
* внутри всех _группирующих_ скобок

Если посмотреть на тип, описанный выше, то можно заметить, что самый правый "указатель" и самая левая "функция" гарантируют нам, что имя может стоять либо так:
```c++
int (*(*foo)())()
```
либо так:
```c++
int (*(*)foo())()
```
Но только первый вариант соответствует последнему правилу про группирующие скобки, поэтому в итоге имя стоит так:
```c++
int (*(*foo)())()
```
Тогда в итоге по вышеописанным правилам получаем, что `foo is pointer to function returning pointer to function returning int`

### Semantic restrictions
Не любые комбинации производных типов допустимы, можно написать объявление, которое будет корректно с точки зрения синтаксических правил, но не будет являться корректным С++ типом (_синтаксически корректно, но семантически некорректно_).
Приведем несколько примеров:
* Не существует массивов функций, только массив указателей на функции

`array of pointer to function returning...`
* Функции не могут возвращать функции, только указатели на функции

`function returning pointer to function returning...`
* Функции не могут возвращать массивы, только указатели на массивы

`function returning pointer to array of...`
* Только самый левый массив может быть безразмерным, например, потому, что указатели на массивы из разного числа элементов - разные типы 

`char foo[] and char foo[][5] are legal, but char foo[5][] is not`
* Использование `void` ограничено

Нельзя объявить переменную или массив типа `void`, можно только указатель, или же пометить, что функция ничего не возвращает:
```c++
void *foo;            // legal
void foo();           // legal
void foo;             // not legal
void foo[];           // not legal
```

### Упражнения:

* Объявите переменную типа "указатель на функцию, принимающую `void*` и возвращающую `void*`"
<details>
  <summary>Решение</summary>

`void* (*ptr)(void*);`
</details>

* Объявите переменную типа "массив из 15 указателей на функцию, принимающую `int` и ничего не возвращающую"
<details>
  <summary>Решение</summary>

`void (*arr[15])(int);`
</details>

* Объявите переменную типа "массив из указателей на массив из 10 указателей  на функцию, принимающую `double` и возвращающую `int`"
<details>
  <summary>Решение</summary>

`int (*(*arr[])[10])(double);`
</details>

* Расшифруйте тип переменной `int (*(*(*(**foo)[])(int, double))[3])(int)` 
<details>
  <summary>Решение</summary>

`foo is pointer to pointer to array of pointers to function taking int and double and returning pointer to array of 3 pointers to function taking int and return int`
</details>

* Куда нужно поставить имя в типе 
<details>
  <summary>Решение</summary>

`foo[][3]`
</details>
* 
<details>
  <summary>Решение</summary>


</details>
* 
<details>
  <summary>Решение</summary>


</details>
* 
<details>
  <summary>Решение</summary>


</details>
* 
<details>
  <summary>Решение</summary>


</details>
* 
